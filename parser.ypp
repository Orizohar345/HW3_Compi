%{
    #include <iostream>
    #include <stdlib.h>
    #include <string>
    #include "hw3_output.hpp"
    #include "tables_stack.h"
    #include "types.h"
    #include <stack>

    using namespace std;
    TablesStack table_stack;
    extern int yylineno;
    extern int yylex();
    int yyerror(const char* message);

%}

%union {
    int val;
    std::string text;
    std::string type;
    struct Exp {
        std::string text;
        std::string type;
        bool is_const;
        int val;
    } exp;
    YYSTYPE() {}
    YYSTYPE& operator=(const YYSTYPE& other) {
        val = other.val;
        text = other.text;
        type = other.type;
        exp = other.exp;
        return *this;
    }
    ~YYSTYPE() {}
}

%token TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC LPAREN RPAREN LBRACE RBRACE INT BYTE B BOOL STRING
%token <text> ID
%token <val> NUM

%type <type> Type
%type <exp> Call
%type <exp> Exp

%right ASSIGN
%left OR
%left AND
%left RELOP_EQ
%left RELOP_REL
%left BINOP_ADD
%left BINOP_MULT
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE

%%

Program : Statements { table_stack.removeTopTable(); }
        ;

Statements : Statement {}
           | Statements Statement {}
           ;

Statement : LBRACE { table_stack.addNewTable(); } Statements RBRACE { table_stack.removeTopTable(); }
          | Type ID SC {
                if (table_stack.entryExists($2)) {
                    output::errorDef(yylineno, $2);
                    exit(1);
                }

                table_stack.addToTopTable(Entry($2, $1));
            }
          | Type ID ASSIGN Exp SC {
            printf("0");
                if (!$4.is_const && !table_stack.entryExists($4.text)) {
                    printf("1");
                    output::errorUndef(yylineno, $4.text);
                    exit(1);
                }

                if (table_stack.entryExists($2)) {
                    printf("2");
                    output::errorDef(yylineno, $2);
                    exit(1);
                }

                if ($1 != $4.type && ($1 != "INT" && $4.type != "BYTE")) {
                    printf("3");
                    output::errorMismatch(yylineno);
                    exit(1);
                }

                table_stack.addToTopTable(Entry($2, $1));
            }
          | ID ASSIGN Exp SC {
                if ((!$3.is_const && !table_stack.entryExists($3.text)) || table_stack.entryExists($3.text)) {
                    output::errorUndef(yylineno, $3.text);
                    exit(1);
                }

                if ($1 != $3.type && ($1 != "INT" && $3.type != "BYTE")) {
                    output::errorMismatch(yylineno);
                    exit(1);
                }
            }
          | Call SC {}
          | RETURN SC {}
          | IF LPAREN M1 RPAREN Statement M2
          | IF LPAREN M1 RPAREN Statement M2 ELSE { table_stack.addNewTable(); } Statement { table_stack.removeTopTable(); }
          | WHILE LPAREN Exp RPAREN {
                if ((!$3.is_const && !table_stack.entryExists($3.text)) || table_stack.entryExists($3.text)) {
                    output::errorUndef(yylineno, $3.text);
                    exit(1);
                }

                if ($3.type != "BOOL") {
                    output::errorMismatch(yylineno);
                }

                table_stack.addNewTable();
                table_stack.addToTopTable(Entry("WHILE", "WHILE"), true);
            } Statement { table_stack.removeTopTable(); }
          | BREAK SC { if (!table_stack.entryExists("WHILE")) { output::errorUnexpectedBreak(yylineno); exit(1); } }
          | CONTINUE SC { if (!table_stack.entryExists("WHILE")) { output::errorUnexpectedContinue(yylineno); exit(1); } }
          ;

Call : ID LPAREN Exp RPAREN {
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            $$.type = verifyFunc($1, $3.type, yylineno);
            $$.is_const = true;
        }
     ;

Type : INT { $$ = std::string("INT"); }
     | BOOL { $$ = std::string("BOOL"); }
     | BYTE { $$ = std::string("BYTE"); }
     ;

Exp : LPAREN Exp RPAREN {
            if (!$2.is_const && !table_stack.entryExists($2.text)) {
                output::errorUndef(yylineno, $2.text);
                exit(1);
            }
            $$.text = $2.text;
            $$.type = $2.type;
            $$.is_const = $2.is_const;
        }
    | Exp BINOP_MULT Exp {
            if (!$1.is_const && !table_stack.entryExists($1.text)) {
                output::errorUndef(yylineno, $1.text);
                exit(1);
            }
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            $$.type = verifyBinop($1.type, $3.type, yylineno);
            $$.is_const = true;
        }
    | Exp BINOP_ADD Exp {
            if (!$1.is_const && !table_stack.entryExists($1.text)) {
                output::errorUndef(yylineno, $1.text);
                exit(1);
            }
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            $$.type = verifyBinop($1.type, $3.type, yylineno);
            $$.is_const = true;
        }
    | ID {printf("HERE"); $$.text = $1; $$.is_const = false; }
    | Call { $$.text = $1.text; $$.type = $1.type; $$.is_const = $1.is_const; }
    | NUM { $$.type = "INT"; $$.is_const = true; }
    | NUM B { $$.type = "BYTE"; $$.is_const = true; }
    | STRING { $$.type = "STRING"; $$.is_const = true; }
    | TRUE { $$.type = "BOOL"; $$.is_const = true; }
    | FALSE { $$.type = "BOOL"; $$.is_const = true; }
    | NOT Exp {
            if (!$2.is_const && !table_stack.entryExists($2.text)) {
                output::errorUndef(yylineno, $2.text);
                exit(1);
            }
            if ($2.type != "BOOL") {
                output::errorMismatch(yylineno);
                exit(1);
            }
            $$.type = "BOOL";
            $$.is_const = true;
        }
    | Exp AND Exp {
            if (!$1.is_const && !table_stack.entryExists($1.text)) {
                output::errorUndef(yylineno, $1.text);
                exit(1);
            }
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            if ($1.type != "BOOL") {
                output::errorMismatch(yylineno);
                exit(1);
            }
            if ($3.type != "BOOL") {
                output::errorMismatch(yylineno);
                exit(1);
            }
            $$.type = "BOOL";
            $$.is_const = true;
        }
    | Exp OR Exp {
            if (!$1.is_const && !table_stack.entryExists($1.text)) {
                output::errorUndef(yylineno, $1.text);
                exit(1);
            }
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            if ($1.type != "BOOL") {
                output::errorMismatch(yylineno);
                exit(1);
            }
            if ($3.type != "BOOL") {
                output::errorMismatch(yylineno);
                exit(1);
            }
            $$.type = "BOOL";
            $$.is_const = true;
        }
    | Exp RELOP_EQ Exp {
            if (!$1.is_const && !table_stack.entryExists($1.text)) {
                output::errorUndef(yylineno, $1.text);
                exit(1);
            }
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            verifyNumeric($1.type, $3.type, yylineno);
            $$.type = "BOOL";
            $$.is_const = true;
        }
    | Exp RELOP_REL Exp {
            if (!$1.is_const && !table_stack.entryExists($1.text)) {
                output::errorUndef(yylineno, $1.text);
                exit(1);
            }
            if (!$3.is_const && !table_stack.entryExists($3.text)) {
                output::errorUndef(yylineno, $3.text);
                exit(1);
            }
            verifyNumeric($1.type, $3.type, yylineno);
            $$.type = "BOOL";
            $$.is_const = true;
        }
    | LPAREN Type RPAREN Exp {
            if (!$4.is_const && !table_stack.entryExists($4.text)) {
                output::errorUndef(yylineno, $4.text);
                exit(1);
            }
            verifyNumeric($2, $4.type, yylineno);
            $$.text = $4.text;
            $$.type = $2;
            $$.is_const = true;
        }
    ;

M1 : Exp    {
                    printf("BUG");
                    if ((!$1.is_const && !table_stack.entryExists($1.text)) || table_stack.entryExists($1.text)) {
                        output::errorUndef(yylineno, $1.text);
                        exit(1);
                    }
                    if ($1.type != "BOOL") {
                        output::errorMismatch(yylineno);
                    }
                    table_stack.addNewTable();
            }
   ;

M2 : { table_stack.removeTopTable(); }
   ;

%%

int main()
{
    yyparse();
}

int yyerror(const char* message)
{
    output::errorSyn(yylineno);
    exit(0);
}
